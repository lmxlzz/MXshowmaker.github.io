<search>
    
     <entry>
        <title>A First Course in Probability - part 1</title>
        <url>/post/2021/04/a_first_course_in_probability_9th_1/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>math</tag><tag>probability</tag>
        </tags>
        <content type="html"> 前言 由于对于概率论的基础存在需求，这里重新回顾一下之前所学的概率论。使用《概率论基础教程》一书，这里记录一下阅读笔记和一些个人的思考。
part 1 记录前三章的内容。
Combinatorial Analysis The basic principle of counting Suppose that two experiments are to be performed. Then if experiment 1 can result in any one of m possible outcomes and if, for each outcome of experiment 1, there are n possible outcomes of experiment 2, then together there are mn possible outcomes of the two experiments.
需要注意的是，这里要求实验1的每个结果都需有n个实验2的结果。
这里可以把两个实验推广到$r$个实验。
Permutations   给$n$个distinguishable的物体进行排序，一共有 $n!$ (read as “n factorial”)种结果。
  对于 certain of the objects are indistinguishable 的情况，需要除掉在各自类内排序的数目。
 例子：     Combinations 组合：把$n$个objects划分成$r$组。组合对于每个组内的object不计较顺序。
 例子：从 abcde中取出3个。   组合中的公式 The binomial theorem 这个可以用1. 数值法来证明。2. 使用组合法来证明：从n个(x&#43;y)中取出k个x已经n-k个y。
Multinomial Coefficients 将n个objects分成r组，这r组所有元素数目之和是n。这个与组合数的区别在于，组合数是从n个objects中抽出部分objects，而多项式系数则是对n个objects进行划分。
这个记做：
例子：
 第一类例子   这两个例子分成的组都是distinguishable。   第二类例子   这个例子中，分的两个组是indistinguishable，因此需要除以这两个组的排列数。    一个很有意思的例子：
对于第二问，可以把问题转成，n个位置的下标表示各自的排名。现在给n个人安排排名，那么有$n!$种结果。
The Number of Integer Solutions of Equations 正整数方程解。对于方程$x_1&#43;x_2&#43;…&#43;x_r = n$，这里$ x_i &amp;gt;0$可以看作有n个objects，在n个objects之间(n-1)个位置插入板子，把n个objects分成r组。那么就是在(n-1)个位置中，选择(r-1)个位置来插入板子。如图：
例子：
- ![image-20210501123250586](A_First_Course_in_Probability_9th_1.assets/image-20210501123250586.png) - 这个例子的第一问，里面$x_i \geq 0$，而上面的公式是要求 $x_i &amp;gt;0$即正数，那么我们可以使用换元法，把$x_i$转换成正整数。 - 对于第二问，可以无中生有，构造成 $x_5$用来表示没有被投资的资金。  Summary  The basic principle of counting  对于每个实验一的结果，在实验二中都有相同的实验结果数目。   排列  区分 distinguishable 和 indistinguishable   组合  从 n 个 objects 中取出 r 个   多项式系数  区别于 组合数， 是把n个 objects 划分为 r 组   正整数方程解的数目  挡板法 自然数或者负数转正整数    Axioms of Probability </content>
    </entry>
    
     <entry>
        <title>理解pytorch算子的使用</title>
        <url>/post/2021/04/%E7%90%86%E8%A7%A3pytorch%E7%AE%97%E5%AD%90%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>pytorch</tag>
        </tags>
        <content type="html"> torch.gather 官方文档
API接口：torch.gather(input, dim, index, *, sparse_grad=False, out=None) → Tensor
按照index，在dim维度中取出 input的值到out上。这里out的shape和index的shape是一模一样。
这里用out的下标来表示结果，如下：
out[i][j][k] = input[index[i][j][k]][j][k] # if dim == 0 out[i][j][k] = input[i][index[i][j][k]][k] # if dim == 1 out[i][j][k] = input[i][j][index[i][j][k]] # if dim == 2 如果是 dim=0的情况下，对于当前的out[i][j][k]的值就是就把input[i][j][k]的索引i换成 index[i][j][k]，即就是input[index[i][j][k]][j][k]。
这里举个例子：
&amp;gt;&amp;gt;&amp;gt; a tensor([[-0.1698, 0.2747, 0.4355], [ 0.9775, 0.4312, -0.4442], [ 0.1158, -1.3496, 0.0075], [-0.2946, -1.1240, 0.6257], [-1.9685, -0.0421, -0.7570]]) &amp;gt;&amp;gt;&amp;gt; a.shape torch.Size([5, 3]) # 注意，out的shape与index的shape是一模一样。 # 1. 如果想要从 a 的列中取出一个值，那么dim=0。 # 1.1 每一列一个 &amp;gt;&amp;gt;&amp;gt; b tensor([[4, 2, 3]]) &amp;gt;&amp;gt;&amp;gt; b.shape torch.Size([1, 3]) # 这个时候使用gather，会改变行标。 &amp;gt;&amp;gt;&amp;gt; torch.gather(a, 0, b) tensor([[-1.9685, -1.1240, 0.0075]]) # 可以看到，这里只改变dim=0的下标，换句话说，就是保持其他坐标，从对应的dim=0里面来选。 # 1.2 每一列多个 &amp;gt;&amp;gt;&amp;gt; b tensor([[4, 4], [3, 3], [2, 2], [1, 1], [0, 0]]) &amp;gt;&amp;gt;&amp;gt; b.shape torch.Size([5, 2]) # 改变行标。 注意，index的列数目【小于、等于】src的列数。 index的行数可以【大于、等于、小于】src的列数 &amp;gt;&amp;gt;&amp;gt; torch.gather(a, 0, b) tensor([[-1.9685, -0.0421], [-0.2946, -1.1240], [ 0.1158, -1.3496], [ 0.9775, 0.4312], [-0.1698, 0.2747]]) # 2. 如果想要把 a 按照行来取值，那么dim=1。 # dim=1就和dim=0非常类似。 # 这边举一个 ”每一行取出多个“的例子 &amp;gt;&amp;gt;&amp;gt; c tensor([[1, 2], [2, 1], [2, 0]]) &amp;gt;&amp;gt;&amp;gt; c.shape torch.Size([3, 2]) &amp;gt;&amp;gt;&amp;gt; torch.gather(a, 1, c) tensor([[ 0.2747, 0.4355], [-0.4442, 0.4312], [ 0.0075, 0.1158]]) torch.scatter_ 官方文档
API接口：torch.Tensor.scatter_(dim, index, src, reduce=None) → Tensor
将src的值，根据index和dim写到self变量上。这里会遍历src的每个值，将src的每个值都分配到self上。对于self的变化情况如下：
self[index[i][j][k]][j][k] = src[i][j][k] # if dim == 0 self[i][index[i][j][k]][k] = src[i][j][k] # if dim == 1 self[i][j][index[i][j][k]] = src[i][j][k] # if dim == 2 与torch.gather非常的类似。
举个例子：【Pytorch】scatter函数详解
&amp;gt;&amp;gt;&amp;gt; a tensor([[0., 1., 2., 3., 4.], [5., 6., 7., 8., 9.]]) &amp;gt;&amp;gt;&amp;gt; a.shape torch.Size([2, 5]) &amp;gt;&amp;gt;&amp;gt; b tensor([[0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.]]) &amp;gt;&amp;gt;&amp;gt; b.shape torch.Size([3, 5]) &amp;gt;&amp;gt;&amp;gt; index tensor([[1, 2, 1, 1, 2], [2, 0, 2, 1, 0]]) &amp;gt;&amp;gt;&amp;gt; index.shape torch.Size([2, 5]) # 所有的改变都是在self身上。现在我们对b进行scatter_， # 那么就是将src=a的每个值，都按照index和dim，分配到self=b的身上。 &amp;gt;&amp;gt;&amp;gt; b.scatter_(dim=0, index=index, src=a) tensor([[0., 6., 0., 0., 9.], [0., 0., 2., 8., 0.], [5., 1., 7., 0., 4.]]) # 解释： # 对于src[0][0]，会被分配到 self[index[0][0]][0] 即 self[1][0] # 对于src[1][0]，会被分配到 self[index[1][0]][0] 即 self[2][0] # 对于src[0][1]，会被分配到 self[index[0][1]][1] 即 self[2][1]	 # dim代表的含义就是当前的src[i][j]被分配到所指定的dim中第index的位置。 </content>
    </entry>
    
     <entry>
        <title>Convolutional Occupancy Networks </title>
        <url>/post/2021/04/convolutional_occupancy_networks/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>implicit field</tag><tag>convolution</tag>
        </tags>
        <content type="html"> 相关信息 Title: Convolutional Occupancy Networks
Link: https://arxiv.org/abs/2003.04618
Github Link: https://github.com/autonomousvision/convolutional_occupancy_networks
收录于 ECCV20
Motivation 这篇文章是在他们组之前工作 Occupancy Networks: Learning 3D Reconstruction in Function Space 的基础上加入卷积操作的升级版。
之前的一些在隐势场上的工作如： IM-Net, OccNet等等，在细节上的效果不是非常的理想。ConvOccNet这篇文章的作者认为主要的原因是他们都用全连接（fully-conneted layer）来训练网络，无法有效的获取空间（也可以认为是local 相对于 global 的特征）。
例如，Fig.1中的(a)，对于每个 query point而言，输入的特征都是通过 全连接层得到的，全连接层无法像卷积那样有效的包含local information。Fig.1中的(b)，3D Feature Volume是通过3D卷积得到的，这个卷积的过程中可以有效的包含local information。
同时，作者还说了，之前的那些基于全连接层的隐势场工作没办法在场景重建上work，这同样是由于缺少了卷积操作从而导致local information的缺失。使用ConvOccNet是可以重建出细节保存比较好的模型。
补充一点在看这篇paper related work时候注意到的点：
Notable exceptions are PIFu and DISN which use pixel-aligned implicit representations to reconstruct people in clothing or ShapeNet objects.
这两篇用隐势场搞 SVR 的工作都关注到了局部细节上重建。
Methods Encoders 文章提供了基于 3种投影方法与2种输入（一共6种）Encoder。
输入类型 支持两种类型的输入：点云（3k for single object 或者 10k for scene）和 体素($64^3$或者$32^3$)。
对于点云，使用 浅层的PointNet来提取特征。
对于体素，使用 3d 卷积提取特征。
投影方法 这块地方我觉得是整篇文章的重点。
这里以点云的输入为例子，参考图二：
 one plane  Fig2(a). 将每个点的特征（通过PointNet得到）投影到 ground plane上。 对于ground plane上的每个点最后的feature是在 【以这个点为中心，和四周的四个点的中点连线形成的正方形区域(fig2(a)地面的红框)内所有点的 average pooling】。 得到 $H\times W\times d$   three plane  与 one plane 类似，就是需要投影到 xy, yz, zx 三个平面上。 得到 3个 $H\times W\times d$   volume  不需要投影，只需要将同一个voxel cell 中feature 进行 average pooling。 $H\times W\times D\times d$    Decoders 这里就用到了卷积。对于 one plane ，将 这个plane的上的特征 $H\times W\times d$ 使用一次基于 hourglass结构的Unet。我是觉得，其实 PointNet是可以获取 local 与 global 之间的关系，这里用 卷积，是将局部的一小撮点云之间的联系加深，在同一个局部的特征会被加强体现出来（通过Unet的卷积）。
对于 three plane，操作是与 one plane 类似的，然后这3个Unet是共享参数的。对于 volume的话，就是使用 3d unet。
在进行卷积操作以后，后面的步骤其实与 OccNet 是类似的。搞一个MLP，把 query point在上面算出来的特征与query point 作为输入，把这个 query point 是否 occupancy的概率作为输出。 $$ f_{\theta}(P, \psi(P, x)) \rightarrow [0, 1] $$
$x$是输入的点云提取的特征，$P$是query point。
Training and Inference loss的话比较简单，就是将预测出来的2048个query point的occupancy值和gt计算交叉熵。
在训练好隐势场之后，为了获取 mesh，用了和 OccNet 一样的算法， MISE(对Marching Cube进行改进，加速mesh的生成速度和质量)。
Experiments 在 单个object，scene 上对模型进行测试。
我从作者的实验结果上感觉，对于single object以点云作为输入的情况下， three plane 和 volume的形式重建出来的效果比较好。
对于体素输入的话，one plane的效果是坏掉了。
scene level 作者在文章中特别提到：
While high-resolution canonical plane features capture fine details they are prone to noise. Low-resolution volumetric features are instead more robust to noise, yet produce smoother surfaces
然后他就在场景的重建中【把 plane 和 volume 两种方法互补起来作为一种方法】，在ablation study中一起做比较。
需要注意的点  The increase in plane resolution for the single plane variant does not result in a clear performance boost, demonstrating that higher resolution does not necessarily guarantee better performance.  不一定越高越好，可能 plane 的精度以后用的时候就卡在 64 或者 128 。   The plane-based approaches are more affected by the domain shift。  从Table 5看的。 We find that 3D CNNs are more robust to noise as they aggregate features from all neighbors which results in smooth outputs.    Ending 因为最近可能要用到这个工作，就重新把它拿出来再看了一遍，暂时还没有过一遍代码，理解的并不是非常深入。
</content>
    </entry>
    
     <entry>
        <title>GLOW</title>
        <url>/post/2021/04/glow/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>flow</tag><tag>generative model</tag>
        </tags>
        <content type="html"> 背景知识 判别模型 vs 生成模型
数值计算 &amp;amp; 采样计算 见过最直观的关于vae的解释变分自编码器介绍、推导及实现
苏剑林
content 知乎real-NVP 里面的【RealNVP中的多尺度结构图示】是讲解的真清楚。
以下是苏剑林关于 actnorm的评价
所以，这一点是需要批评的，纯粹将旧概念换了个新名字罢了。当然，批评的是 OpenAI 在 Glow 中乱造新概念，而不是这个层的效果。缩放平移的加入，确实有助于更好地训练模型。而且，由于 Actnorm 的存在，仿射耦合层的尺度变换已经显得不那么重要了。 我们看到，相比于加性耦合层，仿射耦合层多了一个尺度变换层，从而计算量翻了一倍。但事实上相比加性耦合，仿射耦合效果的提升并不高（尤其是加入了 Actnorm 后），所以要训练大型的模型，为了节省资源，一般都只用加性耦合，比如 Glow 训练 256x256 的高清人脸生成模型，就只用到了加性耦合。 小结论：使用actnorm之后，可以在耦合层中只使用加性耦合。
随手先记录一下，等待后续更新。
Log-likelihood-based methods:
- VAE - FLOW - AUTO-REGRESSIVE  $\log p_G(x_i) = \log \pi(G^{-1}(x_i)) &#43; \log|\det(J_{G^{-1}})|$
最大似然目标： $$ p_K (x^i) = \pi(z^i)(|\det (J_{G_1^{-1}})|)&amp;hellip;(|\det (J_{G_k^{-1}})|) $$
取对数之后： $$ \log p_K (x^i) = \log \pi(z^i) &#43; \sum_{h=1}^K \log (|\det (J_{G_h^{-1}})|) $$ 要使得 $x^i$的出现概率最大，就得保证$z^i$ 在Gaussian中最大，这会导致$z^i$全部趋近于0。
但是后面的求和会限制$z^i$全部趋近于0。
详细的参考来自于李宏毅机器学习2019(国语)，讲解的非常清晰。
【学习笔记】生成模型——流模型（Flow）
</content>
    </entry>
    
     <entry>
        <title>Hugo 搭建个人博客 —- My first post</title>
        <url>/post/my_first_post/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>blog</tag>
        </tags>
        <content type="html"> hugo install 使用brew进行安装。
环境：MacOS,Big Sur
brew install hugo hugo version # 安装正确的话，可以正常查看 Themes 在安装好hugo之后，进入hugo官方主题模板选择心仪的模板。这里我选择了erblog.
为blog创建一个文件夹： xxx-blog（名字随意）。
cd xxx-blog mkdir themes git clone https://github.com/ertuil/erblog themes/erblog cp themes/erblog/exampleSite/config.toml .	#使用模板自带的配置文件替换默认配置文件 对config.toml进行编辑
DefaultContentLanguage = &amp;#34;zh-cn&amp;#34; # 修改为中文 请到Erblog 的Configuration中查看更多的参数设置。
e.g. author, bio,
创建blog cd xxx-blog hugo new post/my-first-post.md 在此基础上编辑新建的文章，添加内容并保存。
加入 tag 标签 在标头加入：
tags: blog 公式的显示 为了加速渲染，只在每篇文章的标头加
math: true 如果为了方便，可以在config文件中加
math=true 显示的效果 这是行内公式$12_{ab}^{12bv}$行内公式。
这是行间公式 $$ abc_{123}^{abv_{ab}} $$ 这是特殊符号测试：!@#%^&amp;amp;*()_&#43;${ } () 你好[(hhh)]123 \(123\)hhhhh
做法 参考MathJax渲染数学公式，这篇blog中在主题文件夹（\themes\xxxxx\layouts\partials\footer.html）中，在&amp;quot;&amp;lt;footer&amp;gt;&amp;ldquo;中添加下面代码。
&amp;lt;script type=&amp;#34;text/x-mathjax-config&amp;#34;&amp;gt; MathJax.Hub.Config({ tex2jax: { inlineMath: [[&amp;#39;$&amp;#39;,&amp;#39;$&amp;#39;], [&amp;#39;\\(&amp;#39;,&amp;#39;\\)&amp;#39;]], displayMath: [[&amp;#39;$$&amp;#39;,&amp;#39;$$&amp;#39;], [&amp;#39;\[&amp;#39;,&amp;#39;\]&amp;#39;]], processEscapes: true, processEnvironments: true, skipTags: [&amp;#39;script&amp;#39;, &amp;#39;noscript&amp;#39;, &amp;#39;style&amp;#39;, &amp;#39;textarea&amp;#39;, &amp;#39;pre&amp;#39;], TeX: { equationNumbers: { autoNumber: &amp;#34;AMS&amp;#34; }, extensions: [&amp;#34;AMSmath.js&amp;#34;, &amp;#34;AMSsymbols.js&amp;#34;] } } }); &amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; async src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 但是上面这种做法会导致“[”和“]”被识别为公式而无法输出。因此，这里选择了比较不常见的组合来代替，代码如下：
&amp;lt;script type=&amp;#34;text/x-mathjax-config&amp;#34;&amp;gt; MathJax.Hub.Config({ tex2jax: { inlineMath: [[&amp;#39;$&amp;#39;,&amp;#39;$&amp;#39;], [&amp;#39;~&#43;(&amp;#39;,&amp;#39;~&#43;)&amp;#39;]], displayMath: [[&amp;#39;$$&amp;#39;,&amp;#39;$$&amp;#39;], [&amp;#39;~&#43;[&amp;#39;,&amp;#39;~&#43;]&amp;#39;]], processEscapes: true, processEnvironments: true, skipTags: [&amp;#39;script&amp;#39;, &amp;#39;noscript&amp;#39;, &amp;#39;style&amp;#39;, &amp;#39;textarea&amp;#39;, &amp;#39;pre&amp;#39;], TeX: { equationNumbers: { autoNumber: &amp;#34;AMS&amp;#34; }, extensions: [&amp;#34;AMSmath.js&amp;#34;, &amp;#34;AMSsymbols.js&amp;#34;] } } }); &amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; async src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 图片的显示 显示效果 测试图片1
测试图片2
做法 由于我在 typora中图片存储的路径是”./${filename}.assets“，这是一个相对路径。hugo将md文件翻译成html文件的时候，不会改变这个路径，但是html文件与”./${filename}.assets“在public文件中不再是在同一个目录下了，这个时候html文件中的相对路径需要添加&amp;rdquo;../&amp;ldquo;的前缀。因此，需要在写一个与处理公式类似的脚本。在主题文件夹（\themes\erblog\layouts\partials\footer.html）中，在&amp;rdquo;&amp;lt;footer&amp;gt;&amp;ldquo;中添加下面代码，遍历所有的image，给src属性添加&amp;rdquo;../&amp;ldquo;前缀。由于对Javascript不熟悉，参考了用getElementsByTagName遍历HTML DOM元素 这篇博客以及JS怎么更换img中src路径的内容来遍历所有image。
&amp;lt;script&amp;gt; var local_imgs=document.getElementsByTagName(&amp;#39;img&amp;#39;); for (var i = 0; i &amp;lt; local_imgs.length; i&#43;&#43;) { var src = local_imgs[i].getAttribute(&amp;#39;src&amp;#39;); local_imgs[i].setAttribute(&amp;#39;src&amp;#39;,&amp;#34;../&amp;#34;&#43;src); } &amp;lt;/script&amp;gt; 这么做还有一个好处，那就是当我把md文件移动到另一个文件夹，我只需要将对应的”./${filename}.assets“移动到和md一级的目录，本地的md能够正常显示，同时翻译后的html文件也能正常显示。
生成以及上传 生成 在xxx-blog目录下，先使用hugo进行编译，
hugo 此时xxx-blog目录下会多出一个 public 文件夹来。这便是 Hugo 生成的网站。
hugo server -D # 在本地查看 部署到github.io 如果是第一次执行，需要
cd public git init git remote add origin https://github.com/[Github 用户名]/[Github 用户名].github.io.git git add . git commit -m &amp;#34;[介绍，随便写点什么，比如日期]&amp;#34; git push -u origin master 如果不是第一次执行，如下：
git add . git commit -m &amp;#34;[介绍，随便写点什么，比如日期]&amp;#34; git push -u origin master Ending 至此，使用 hugo 搭建部署在 github.io的个人博客的流程介绍完毕。
第一次写blog，对这个搭建过程进行记录并且以此练练手。
Reference  MathJax渲染数学公式 git修改/添加/删除远程仓库 用getElementsByTagName遍历HTML DOM元素 JS怎么更换img中src路径 用hugo搭建属于自己的个人博客(mac环境) 如何利用 GitHub Pages 和 Hugo 轻松搭建个人博客？  更新 由于觉得之前的主题功能不够，使用了 hexo的 Next的主题。这里用了xtfly的hugo-theme-next 主题。
mkdir themes git clone https://github.com/xtfly/hugo-theme-next themes/next cp themes/next/config.toml .	#使用模板自带的配置文件替换默认配置文件 之后进入config.toml根据自己的需求修改个人信息。
有一些图片和公式的不兼容，执行了与之前类似的操作，如下：
每篇blog的时间显示在我这里是错误的，于是我在config.toml把时间的几个format注释掉了，然后就正常了。
修改公式和图片显示 由于多了一张存放在static文件下的的 author.jpg，这导致之前的js脚本会把这张图的相对路径也加上../，从而出现这张图无法正确加载。我在看了html的源码后发现，author.jpg一直都是最后一张图，于是遍历的时候改成i &amp;lt; local_imgs.length-1即可。整&amp;lt;footer.html&amp;gt;的修改就是在路径（\themes\xxxxx\layouts\partials\footer.html）添加如下代码：
&amp;lt;script type=&amp;#34;text/x-mathjax-config&amp;#34;&amp;gt; MathJax.Hub.Config({ tex2jax: { inlineMath: [[&amp;#39;$&amp;#39;,&amp;#39;$&amp;#39;], [&amp;#39;~&#43;(&amp;#39;,&amp;#39;~&#43;)&amp;#39;]], displayMath: [[&amp;#39;$$&amp;#39;,&amp;#39;$$&amp;#39;], [&amp;#39;~&#43;[&amp;#39;,&amp;#39;~&#43;]&amp;#39;]], processEscapes: true, processEnvironments: true, skipTags: [&amp;#39;script&amp;#39;, &amp;#39;noscript&amp;#39;, &amp;#39;style&amp;#39;, &amp;#39;textarea&amp;#39;, &amp;#39;pre&amp;#39;], TeX: { equationNumbers: { autoNumber: &amp;#34;AMS&amp;#34; }, extensions: [&amp;#34;AMSmath.js&amp;#34;, &amp;#34;AMSsymbols.js&amp;#34;] } } }); &amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; async src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; var local_imgs=document.getElementsByTagName(&amp;#39;img&amp;#39;); for (var i = 0; i &amp;lt; local_imgs.length-1; i&#43;&#43;) { var src = local_imgs[i].getAttribute(&amp;#39;src&amp;#39;); local_imgs[i].setAttribute(&amp;#39;src&amp;#39;,&amp;#34;../&amp;#34;&#43;src); } &amp;lt;/script&amp;gt; 增加新功能  评论 访问统计 搜索  评论 使用 Valine平台。参考Valine的官方指导手册，先进行实名注册（包括支付宝认证与邮箱认证还需要绑定手机，感觉贼麻烦），然后创建方案（参考教程）。
记住 App ID 和 App Key。在hugo中安装 valine，如下：
# Install valine npm install valine --save 参考Hugo加入评论的功能来配置Hugo下的valine设置。
 在 config.toml 中最底部加入以下代码（Valine基本配置）：  # Valine. # You can get your appid and appkey from https://leancloud.cn # more info please open https://valine.js.org [params.valine] enable = true appId = &amp;#39;Your appId&amp;#39; appKey = &amp;#39;Your appKey&amp;#39; notify = false # mail notifier , https://github.com/xCss/Valine/wiki verify = false # Verification code avatar = &amp;#39;mm&amp;#39; placeholder = &amp;#39;说点什么吧...&amp;#39; visitor = true 在 layouts/partials/ 中创建 comments.html 文件，文件内容如下：  &amp;lt;!-- valine --&amp;gt; {{- if .Site.Params.valine.enable -}} &amp;lt;!-- id 将作为查询条件 --&amp;gt; &amp;lt;div id=&amp;#34;vcomments&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script src=&amp;#34;//cdn1.lncld.net/static/js/3.0.4/av-min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#39;//unpkg.com/valine/dist/Valine.min.js&amp;#39;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; new Valine({ el: &amp;#39;#vcomments&amp;#39; , appId: &amp;#39;{{ .Site.Params.valine.appId }}&amp;#39;, appKey: &amp;#39;{{ .Site.Params.valine.appKey }}&amp;#39;, notify: &amp;#39;{{ .Site.Params.valine.notify }}&amp;#39;, verify: &amp;#39;{{ .Site.Params.valine.verify }}&amp;#39;, avatar:&amp;#39;{{ .Site.Params.valine.avatar }}&amp;#39;, placeholder: &amp;#39;{{ .Site.Params.valine.placeholder }}&amp;#39;, visitor: &amp;#39;{{ .Site.Params.valine.visitor }}&amp;#39; }); &amp;lt;/script&amp;gt; {{- end -}} 引入comments  在 layouts/_default/single.html 中加入下面的代码，以引入 comments.html
&amp;lt;div class=&amp;#34;post-comment&amp;#34;&amp;gt; &amp;lt;!-- 加入评论功能 --&amp;gt; {{ partial &amp;#34;comments.html&amp;#34; . }} &amp;lt;/div&amp;gt; 然后重新启动hugo即可看到评论，评论的管理后台在 valine。
访问统计  评论数目  在themes/next/layouts/partials/head.html文件中引入不蒜子js文件
&amp;lt;!-- 不蒜子 --&amp;gt; &amp;lt;script async src=&amp;#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 创建文件：themes/next/layouts/partials/post/viewnum.html
&amp;amp;nbsp; | &amp;amp;nbsp; &amp;lt;span class=&amp;#34;article-tag&amp;#34;&amp;gt; &amp;lt;i class=&amp;#34;fa fa-eye&amp;#34;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;span id=&amp;#34;busuanzi_container_page_pv&amp;#34;&amp;gt; &amp;lt;span id=&amp;#34;busuanzi_value_page_pv&amp;#34;&amp;gt;0&amp;lt;/span&amp;gt; &amp;lt;/span&amp;gt; &amp;lt;/span&amp;gt; 在 themes/next/layouts/_default/single.html中添加这个viewnum.html文件
&amp;lt;div class=&amp;#34;post-meta&amp;#34;&amp;gt; {{ partial &amp;#34;post/date.html&amp;#34; .}} {{ partial &amp;#34;post/category.html&amp;#34; .}} {{ partial &amp;#34;post/readtime.html&amp;#34; .}} {{ partial &amp;#34;post/viewnum.html&amp;#34; .}} &amp;lt;/div&amp;gt; 就可以在文章里面看到一个小眼睛了。
 站点统计  在 themes/next/layouts/partials/footer.html中的第一个**&amp;lt;div&amp;gt;**添加如下代码：
&amp;lt;span class=&amp;#34;with-love&amp;#34;&amp;gt;&amp;lt;i class=&amp;#34;fa fa-heart&amp;#34;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;span id=&amp;#34;busuanzi_container_site_pv&amp;#34;&amp;gt; 总访问量：&amp;lt;span id=&amp;#34;busuanzi_value_site_pv&amp;#34;&amp;gt;&amp;lt;span id=&amp;#34;busuanzi_value_site_pv&amp;#34;&amp;gt;0&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;with-love&amp;#34;&amp;gt;&amp;lt;i class=&amp;#34;fa fa-heart&amp;#34;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;span id=&amp;#34;busuanzi_container_site_uv&amp;#34;&amp;gt; 总访客数: &amp;lt;span id=&amp;#34;busuanzi_value_site_uv&amp;#34;&amp;gt;&amp;lt;span id=&amp;#34;busuanzi_value_site_uv&amp;#34;&amp;gt;0&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/span&amp;gt; 效果如下：
为了解决错误的统计量，需要添加如下一行代码：
&amp;lt;meta name=&amp;#34;referrer&amp;#34; content=&amp;#34;no-referrer-when-downgrade&amp;#34;&amp;gt; 在之前themes/next/layouts/partials/head.html中
&amp;lt;!-- 不蒜子 --&amp;gt; &amp;lt;script async src=&amp;#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;meta name=&amp;#34;referrer&amp;#34; content=&amp;#34;no-referrer-when-downgrade&amp;#34;&amp;gt; 搜索 这个魔改的 next主题自带了 local search，不过我试了一下，中文的话得要2个字起步好像。
补一句：至于 hexo中的search，可以参考下面的链接。
New Reference 优化Hugo Next主题的过程
Hugo加入评论的功能
女朋友看了我的博客，说太LOW了，于是我搞了一天~
人人都爱小雀斑&amp;rsquo;s blog
</content>
    </entry>
    
</search>