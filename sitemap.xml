<search>
    
     <entry>
        <title>Convolutional Occupancy Networks </title>
        <url>/post/2021/04/convolutional_occupancy_networks/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>implicit field</tag><tag>convolution</tag>
        </tags>
        <content type="html"> 相关信息 Title: Convolutional Occupancy Networks
Link: https://arxiv.org/abs/2003.04618
Github Link: https://github.com/autonomousvision/convolutional_occupancy_networks
收录于 ECCV20
Motivation 这篇文章是在他们组之前工作 Occupancy Networks: Learning 3D Reconstruction in Function Space 的基础上加入卷积操作的升级版。
之前的一些在隐势场上的工作如： IM-Net, OccNet等等，在细节上的效果不是非常的理想。ConvOccNet这篇文章的作者认为主要的原因是他们都用全连接（fully-conneted layer）来训练网络，无法有效的获取空间（也可以认为是local 相对于 global 的特征）。
例如，Fig.1中的(a)，对于每个 query point而言，输入的特征都是通过 全连接层得到的，全连接层无法像卷积那样有效的包含local information。Fig.1中的(b)，3D Feature Volume是通过3D卷积得到的，这个卷积的过程中可以有效的包含local information。
同时，作者还说了，之前的那些基于全连接层的隐势场工作没办法在场景重建上work，这同样是由于缺少了卷积操作从而导致local information的缺失。使用ConvOccNet是可以重建出细节保存比较好的模型。
补充一点在看这篇paper related work时候注意到的点：
Notable exceptions are PIFu and DISN which use pixel-aligned implicit representations to reconstruct people in clothing or ShapeNet objects.
这两篇用隐势场搞 SVR 的工作都关注到了局部细节上重建。
Methods Encoders 文章提供了基于 3种投影方法与2种输入（一共6种）Encoder。
输入类型 支持两种类型的输入：点云（3k for single object 或者 10k for scene）和 体素($64^3$或者$32^3$)。
对于点云，使用 浅层的PointNet来提取特征。
对于体素，使用 3d 卷积提取特征。
投影方法 这块地方我觉得是整篇文章的重点。
这里以点云的输入为例子，参考图二：
 one plane  Fig2(a). 将每个点的特征（通过PointNet得到）投影到 ground plane上。 对于ground plane上的每个点最后的feature是在 【以这个点为中心，和四周的四个点的中点连线形成的正方形区域(fig2(a)地面的红框)内所有点的 average pooling】。 得到 $H\times W\times d$   three plane  与 one plane 类似，就是需要投影到 xy, yz, zx 三个平面上。 得到 3个 $H\times W\times d$   volume  不需要投影，只需要将同一个voxel cell 中feature 进行 average pooling。 $H\times W\times D\times d$    Decoders 这里就用到了卷积。对于 one plane ，将 这个plane的上的特征 $H\times W\times d$ 使用一次基于 hourglass结构的Unet。我是觉得，其实 PointNet是可以获取 local 与 global 之间的关系，这里用 卷积，是将局部的一小撮点云之间的联系加深，在同一个局部的特征会被加强体现出来（通过Unet的卷积）。
对于 three plane，操作是与 one plane 类似的，然后这3个Unet是共享参数的。对于 volume的话，就是使用 3d unet。
在进行卷积操作以后，后面的步骤其实与 OccNet 是类似的。搞一个MLP，把 query point在上面算出来的特征与query point 作为输入，把这个 query point 是否 occupancy的概率作为输出。 $$ f_{\theta}(P, \psi(P, x)) \rightarrow [0, 1] $$
$x$是输入的点云提取的特征，$P$是query point。
Training and Inference loss的话比较简单，就是将预测出来的2048个query point的occupancy值和gt计算交叉熵。
在训练好隐势场之后，为了获取 mesh，用了和 OccNet 一样的算法， MISE(对Marching Cube进行改进，加速mesh的生成速度和质量)。
Experiments 在 单个object，scene 上对模型进行测试。
我从作者的实验结果上感觉，对于single object以点云作为输入的情况下， three plane 和 volume的形式重建出来的效果比较好。
对于体素输入的话，one plane的效果是坏掉了。
scene level 作者在文章中特别提到：
While high-resolution canonical plane features capture fine details they are prone to noise. Low-resolution volumetric features are instead more robust to noise, yet produce smoother surfaces
然后他就在场景的重建中【把 plane 和 volume 两种方法互补起来作为一种方法】，在ablation study中一起做比较。
需要注意的点  The increase in plane resolution for the single plane variant does not result in a clear performance boost, demonstrating that higher resolution does not necessarily guarantee better performance.  不一定越高越好，可能 plane 的精度以后用的时候就卡在 64 或者 128 。   The plane-based approaches are more affected by the domain shift。  从Table 5看的。 We find that 3D CNNs are more robust to noise as they aggregate features from all neighbors which results in smooth outputs.    Ending 因为最近可能要用到这个工作，就重新把它拿出来再看了一遍，暂时还没有过一遍代码，理解的并不是非常深入。
</content>
    </entry>
    
     <entry>
        <title>GLOW</title>
        <url>/post/2021/04/glow/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>flow</tag><tag>generative model</tag>
        </tags>
        <content type="html"> content 知乎real-NVP 里面的【RealNVP中的多尺度结构图示】是讲解的真清楚。
以下是苏剑林关于 actnorm的评价
所以，这一点是需要批评的，纯粹将旧概念换了个新名字罢了。当然，批评的是 OpenAI 在 Glow 中乱造新概念，而不是这个层的效果。缩放平移的加入，确实有助于更好地训练模型。而且，由于 Actnorm 的存在，仿射耦合层的尺度变换已经显得不那么重要了。 我们看到，相比于加性耦合层，仿射耦合层多了一个尺度变换层，从而计算量翻了一倍。但事实上相比加性耦合，仿射耦合效果的提升并不高（尤其是加入了 Actnorm 后），所以要训练大型的模型，为了节省资源，一般都只用加性耦合，比如 Glow 训练 256x256 的高清人脸生成模型，就只用到了加性耦合。 小结论：使用actnorm之后，可以在耦合层中只使用加性耦合。
随手先记录一下，等待后续更新。
Log-likelihood-based methods:
- VAE - FLOW - AUTO-REGRESSIVE  $\log p_G(x_i) = \log \pi(G^{-1}(x_i)) &#43; \log|\det(J_{G^{-1}})|$
最大似然目标： $$ p_K (x^i) = \pi(z^i)(|\det (J_{G_1^{-1}})|)&amp;hellip;(|\det (J_{G_k^{-1}})|) $$
取对数之后： $$ \log p_K (x^i) = \log \pi(z^i) &#43; \sum_{h=1}^K \log (|\det (J_{G_h^{-1}})|) $$ 要使得 $x^i$的出现概率最大，就得保证$z^i$ 在Gaussian中最大，这会导致$z^i$全部趋近于0。
但是后面的求和会限制$z^i$全部趋近于0。
详细的参考来自于李宏毅机器学习2019(国语)，讲解的非常清晰。
【学习笔记】生成模型——流模型（Flow）
</content>
    </entry>
    
     <entry>
        <title>Hugo 搭建个人博客 —- My first post</title>
        <url>/post/my_first_post/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>blog</tag>
        </tags>
        <content type="html"> 1. hugo install 使用brew进行安装。
环境：MacOS,Big Sur
brew install hugo hugo version # 安装正确的话，可以正常查看 2. Themes 在安装好hugo之后，进入hugo官方主题模板选择心仪的模板。这里我选择了erblog.
为blog创建一个文件夹： xxx-blog（名字随意）。
cd xxx-blog mkdir themes git clone https://github.com/ertuil/erblog themes/erblog cp themes/erblog/exampleSite/config.toml .	#使用模板自带的配置文件替换默认配置文件 对config.toml进行编辑
DefaultContentLanguage = &amp;#34;zh-cn&amp;#34; # 修改为中文 请到Erblog 的Configuration中查看更多的参数设置。
e.g. author, bio,
3. 创建blog cd xxx-blog hugo new post/my-first-post.md 在此基础上编辑新建的文章，添加内容并保存。
加入 tag 标签 在标头加入：
tags: blog 4. 公式的显示 为了加速渲染，只在每篇文章的标头加
math: true 如果为了方便，可以在config文件中加
math=true 显示的效果 这是行内公式$12_{ab}^{12bv}$行内公式。
这是行间公式 $$ abc_{123}^{abv_{ab}} $$ 这是特殊符号测试：!@#%^&amp;amp;*()_&#43;${ } () 你好[(hhh)]123 \(123\)hhhhh
做法 参考MathJax渲染数学公式，这篇blog中在主题文件夹（\themes\xxxxx\layouts\partials\footer.html）中，在&amp;quot;&amp;lt;footer&amp;gt;&amp;ldquo;中添加下面代码。
&amp;lt;script type=&amp;#34;text/x-mathjax-config&amp;#34;&amp;gt; MathJax.Hub.Config({ tex2jax: { inlineMath: [[&amp;#39;$&amp;#39;,&amp;#39;$&amp;#39;], [&amp;#39;\\(&amp;#39;,&amp;#39;\\)&amp;#39;]], displayMath: [[&amp;#39;$$&amp;#39;,&amp;#39;$$&amp;#39;], [&amp;#39;\[&amp;#39;,&amp;#39;\]&amp;#39;]], processEscapes: true, processEnvironments: true, skipTags: [&amp;#39;script&amp;#39;, &amp;#39;noscript&amp;#39;, &amp;#39;style&amp;#39;, &amp;#39;textarea&amp;#39;, &amp;#39;pre&amp;#39;], TeX: { equationNumbers: { autoNumber: &amp;#34;AMS&amp;#34; }, extensions: [&amp;#34;AMSmath.js&amp;#34;, &amp;#34;AMSsymbols.js&amp;#34;] } } }); &amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; async src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 但是上面这种做法会导致“[”和“]”被识别为公式而无法输出。因此，这里选择了比较不常见的组合来代替，代码如下：
&amp;lt;script type=&amp;#34;text/x-mathjax-config&amp;#34;&amp;gt; MathJax.Hub.Config({ tex2jax: { inlineMath: [[&amp;#39;$&amp;#39;,&amp;#39;$&amp;#39;], [&amp;#39;~&#43;(&amp;#39;,&amp;#39;~&#43;)&amp;#39;]], displayMath: [[&amp;#39;$$&amp;#39;,&amp;#39;$$&amp;#39;], [&amp;#39;~&#43;[&amp;#39;,&amp;#39;~&#43;]&amp;#39;]], processEscapes: true, processEnvironments: true, skipTags: [&amp;#39;script&amp;#39;, &amp;#39;noscript&amp;#39;, &amp;#39;style&amp;#39;, &amp;#39;textarea&amp;#39;, &amp;#39;pre&amp;#39;], TeX: { equationNumbers: { autoNumber: &amp;#34;AMS&amp;#34; }, extensions: [&amp;#34;AMSmath.js&amp;#34;, &amp;#34;AMSsymbols.js&amp;#34;] } } }); &amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; async src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 5. 图片的显示 显示效果 测试图片1
测试图片2
做法 由于我在 typora中图片存储的路径是”./${filename}.assets“，这是一个相对路径。hugo将md文件翻译成html文件的时候，不会改变这个路径，但是html文件与”./${filename}.assets“在public文件中不再是在同一个目录下了，这个时候html文件中的相对路径需要添加&amp;rdquo;../&amp;ldquo;的前缀。因此，需要在写一个与处理公式类似的脚本。在主题文件夹（\themes\erblog\layouts\partials\footer.html）中，在&amp;rdquo;&amp;lt;footer&amp;gt;&amp;ldquo;中添加下面代码，遍历所有的image，给src属性添加&amp;rdquo;../&amp;ldquo;前缀。由于对Javascript不熟悉，参考了用getElementsByTagName遍历HTML DOM元素 这篇博客以及JS怎么更换img中src路径的内容来遍历所有image。
&amp;lt;script&amp;gt; var local_imgs=document.getElementsByTagName(&amp;#39;img&amp;#39;); for (var i = 0; i &amp;lt; local_imgs.length; i&#43;&#43;) { var src = local_imgs[i].getAttribute(&amp;#39;src&amp;#39;); local_imgs[i].setAttribute(&amp;#39;src&amp;#39;,&amp;#34;../&amp;#34;&#43;src); } &amp;lt;/script&amp;gt; 这么做还有一个好处，那就是当我把md文件移动到另一个文件夹，我只需要将对应的”./${filename}.assets“移动到和md一级的目录，本地的md能够正常显示，同时翻译后的html文件也能正常显示。
6. 生成以及上传 生成 在xxx-blog目录下，先使用hugo进行编译，
hugo 此时xxx-blog目录下会多出一个 public 文件夹来。这便是 Hugo 生成的网站。
hugo server -D # 在本地查看 部署到github.io 如果是第一次执行，需要
cd public git init git remote add origin https://github.com/[Github 用户名]/[Github 用户名].github.io.git git add . git commit -m &amp;#34;[介绍，随便写点什么，比如日期]&amp;#34; git push -u origin master 如果不是第一次执行，如下：
git add . git commit -m &amp;#34;[介绍，随便写点什么，比如日期]&amp;#34; git push -u origin master 7. Ending 至此，使用 hugo 搭建部署在 github.io的个人博客的流程介绍完毕。
第一次写blog，对这个搭建过程进行记录并且以此练练手。
8. Reference  MathJax渲染数学公式 git修改/添加/删除远程仓库 用getElementsByTagName遍历HTML DOM元素 JS怎么更换img中src路径 用hugo搭建属于自己的个人博客(mac环境) 如何利用 GitHub Pages 和 Hugo 轻松搭建个人博客？  9. 更新 由于觉得之前的主题功能不够，使用了 hexo的 Next的主题。这里用了xtfly的hugo-theme-next 主题。
mkdir themes git clone https://github.com/xtfly/hugo-theme-next themes/next cp themes/next/config.toml .	#使用模板自带的配置文件替换默认配置文件 之后进入config.toml根据自己的需求修改个人信息。
有一些图片和公式的不兼容，执行了与之前类似的操作，如下：
每篇blog的时间显示在我这里是错误的，于是我在config.toml把时间的几个format注释掉了，然后就正常了。
修改公式和图片显示 由于多了一张存放在static文件下的的 author.jpg，这导致之前的js脚本会把这张图的相对路径也加上../，从而出现这张图无法正确加载。我在看了html的源码后发现，author.jpg一直都是最后一张图，于是遍历的时候改成i &amp;lt; local_imgs.length-1即可。整&amp;lt;footer.html&amp;gt;的修改就是在路径（\themes\xxxxx\layouts\partials\footer.html）添加如下代码：
&amp;lt;script type=&amp;#34;text/x-mathjax-config&amp;#34;&amp;gt; MathJax.Hub.Config({ tex2jax: { inlineMath: [[&amp;#39;$&amp;#39;,&amp;#39;$&amp;#39;], [&amp;#39;~&#43;(&amp;#39;,&amp;#39;~&#43;)&amp;#39;]], displayMath: [[&amp;#39;$$&amp;#39;,&amp;#39;$$&amp;#39;], [&amp;#39;~&#43;[&amp;#39;,&amp;#39;~&#43;]&amp;#39;]], processEscapes: true, processEnvironments: true, skipTags: [&amp;#39;script&amp;#39;, &amp;#39;noscript&amp;#39;, &amp;#39;style&amp;#39;, &amp;#39;textarea&amp;#39;, &amp;#39;pre&amp;#39;], TeX: { equationNumbers: { autoNumber: &amp;#34;AMS&amp;#34; }, extensions: [&amp;#34;AMSmath.js&amp;#34;, &amp;#34;AMSsymbols.js&amp;#34;] } } }); &amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; async src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; var local_imgs=document.getElementsByTagName(&amp;#39;img&amp;#39;); for (var i = 0; i &amp;lt; local_imgs.length-1; i&#43;&#43;) { var src = local_imgs[i].getAttribute(&amp;#39;src&amp;#39;); local_imgs[i].setAttribute(&amp;#39;src&amp;#39;,&amp;#34;../&amp;#34;&#43;src); } &amp;lt;/script&amp;gt; 增加新功能  评论 访问统计 搜索  评论 使用 Valine平台。参考Valine的官方指导手册，先进行实名注册（包括支付宝认证与邮箱认证还需要绑定手机，感觉贼麻烦），然后创建方案（参考教程）。
# Install valine npm install valine --save 10. New Reference 优化Hugo Next主题的过程
Hugo加入评论的功能
</content>
    </entry>
    
</search>